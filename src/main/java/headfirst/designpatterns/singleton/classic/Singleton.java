package headfirst.designpatterns.singleton.classic;

// NOTE: This is not thread safe!

/**
 * Это не потокобезопасный Singleton.
 * Паттерн Одиночка - гарантирует, что в любой момент времени
 * существует только один экземпляр класса.
 * Этот паттерн часто используют для управления пулами ресурсов
 * — скажем, подключений или программных потоков.
 * И чтобы получить объект, вы не создаете его экземпляр, а
 * запрашиваете его.
 * Паттерн предоставляет глобальную точку доступа к экземпляру:
 * обратившись с запросом к классу в любой точке программы, вы
 * получите ссылку на единственный экземпляр.
 * Это отложенное создание экземпляра, что особенно важно для
 * объектов, создание которых сопряжено с большими затратами
 * ресурсов.
 * <p>
 * «принципе одной обязанности» - Singleton нарушает этот принцип SOLID.
 * Синглетный класс отвечает не только за управление своим экземпляром
 * (и предоставление глобального доступа к нему), но и за выполнение
 * своих основных функций в приложении. Таким образом, можно сказать,
 * что он имеет не одну, а две обязанности.
 * Однако все управление экземпляром осуществляется отдельной подсисте-
 * мой класса; безусловно, это упрощает общую архитектуру. Кроме того,
 * многие разработчики хорошо знают широко распространный паттерн Одиночка.
 * Тем не менее некоторые разработчики считают, что функциональность
 * паттерна Одиночка следует абстрагировать за пределами класса.
 */
public class Singleton {
    //Статическая переменная для хранения единственного экземпляра.
    private static Singleton uniqueInstance;

    /**
     * Приватный конструктор, т.е. закрытый конструктор и
     * из вне через new создать объект этого класса нельзя.
     * только Singleton может создавать экземпляры этого
     * класса с помощью метода getInstance()!
     */
    private Singleton() {
    }

    /**
     * Метод создает и возвращает экземпляр.
     * <p>
     * Метод getInstance() объявлен статическим, что позволяет
     * легко вызвать его в любом месте с использованием
     * синтакиса Singleton.getInstance(). Этот способ
     * ничуть не сложнее обращения к глобальной переменной,
     * но он обладает дополнительными преимуществами — такими,
     * как отложенная инициализация.
     *
     * @return объект класса Singleton
     */
    public static Singleton getInstance() {
        //Если uniqueInstance содержит null, значит, экземпляр
        //еще не создан...
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        //Если uniqueInstance уже содержит значение, сразу
        //переходим к команде return.
        return uniqueInstance;
    }

    // other useful methods here

    /**
     * Как и всякий другой класс, Singleton содержит другие
     * переменные и методы экземпляров.
     *
     * @return строковое значение
     */
    public String getDescription() {
        return "I'm a classic Singleton!";
    }
}
