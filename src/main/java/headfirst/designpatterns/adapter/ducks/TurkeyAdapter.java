package headfirst.designpatterns.adapter.ducks;

/**
 * Задача паттерна Адаптер — преобразовать один интерфейс
 * к другому интерфейсу.
 * <p>
 * Прежде всего необходимо реализовать интерфейс того типа,
 * на который рассчитан ваш клиент.
 * Допустим, нам не хватает объектов Duck и мы хотим использовать вместо них объекты
 * Turkey. Разумеется, простая замена невозможна, потому что эти объекты обладают раз-
 * ными интерфейсами.
 * <p>
 * Адаптер реализует целевой интерфейс и хранит ссылку
 * на экземпляр адаптируемого объекта.
 * <p>
 * Адаптер связывается с адаптируемым объектом посредством композиции.
 * Дополнительное преимущество такого решения заключается в том, что
 * адаптер будет работать с любым субклассом адаптируемого объекта.
 * <p>
 * В паттерне Адаптер проявляются многие признаки качественного ОО-проектирования:
 * обратите внимание на использование композиции для «упаковки» адаптируемого объ-
 * екта в измененный интерфейс. Дополнительное преимущество такого решения заклю-
 * чается в том, что адаптер будет работать с любым субклассом адаптируемого объекта.
 * <p>
 * Использование композиции дает мне немалые преимущества.
 * Можно адаптировать не только отдельный класс, но и все его субклассы.
 */
public class TurkeyAdapter implements Duck {
    //Адаптируемый под клиента объект (композиция)
    Turkey turkey;

    /**
     * Затем следует получить ссылку на адаптируемый объект;
     * обычно это делается в конструкторе.
     *
     * @param turkey объект типа {@link Turkey}
     */
    public TurkeyAdapter(Turkey turkey) {
        //Сохраняем ссылку на адаптируемый объект Turkey
        this.turkey = turkey;
    }

    /**
     * Адаптер должен реализовать все методы интерфейса.
     * Преобразование quack() между классами выполняется
     * просто — реализация вызывает gobble().
     */
    public void quack() {
        turkey.gobble();
    }

    /**
     * Хотя метод fly() входит в оба интерфейса,
     * индюшка не умеет летать на дальние
     * расстояния. Чтобы установить
     * соответствие между этими методами,
     * мы вызываем метод fly() класса Turkey
     * пять раз.
     */
    public void fly() {
        for (int i = 0; i < 5; i++) {
            turkey.fly();
        }
    }
}
